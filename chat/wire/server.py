# Python program to implement server side of chat room.
import select
import time
import sqlite3

from threading import Thread, Event

from wire.chat_service import User
from wire.wire_protocol import pack_packet, unpack_packet


class Listener(Thread):
    def __init__(self, chat_app, conn, addr, id, outfile):
        Thread.__init__(self)
        self.chat_app = chat_app
        self.conn = conn
        self.addr = addr
        self.id = id
        self.outfile = outfile
        
        self.port = port
        self.queue = queue
        self.exit = Event()

        # Create a socket and bind it to the host and port
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server.bind((HOST, self.port))
        self.server.listen(10)

        # Add the server socket to the list of inputs
        self.inputs = [self.server]

    def run(self):
        # Continuously poll for messages while exit event has not been set
        while not self.exit.is_set():
            self.poll_for_messages()

        # Close all socket connections
        for sock in self.inputs:
            sock.close()
            self.inputs.remove(sock)

        print('Exited')

    def poll_for_messages(self):
        # Use select.select to poll for messages
        read_sockets, _, _ = select.select(self.inputs, [], [], 0.1)

        for sock in read_sockets:
            # If the socket is the server socket, accept as a connection
            if sock == self.server:
                client, _ = sock.accept()
                self.inputs.append(client)
            # Otherwise, read the data from the socket
            else:
                data = sock.recv(1024)
                if data:
                    # Read in the data as a big-endian integer
                    self.queue.put(int.from_bytes(data, 'big'))
                # If there is no data, then the connection has been closed
                else:
                    sock.close()
                    self.inputs.remove(sock)

    def shutdown(self):
        print('Listener Shutdown Initiated')
        self.exit.set()


def client_thread(chat_app, conn, addr, id):
    # sends a message to the client whose user object is conn
    message = '<server> Connected to server'
    output = pack_packet(1, message)
    conn.send(output)

    # Define a user object to keep track of the user and state for the thread
    curr_user = User(conn)
    sql_conn = sqlite3.connect('./logs/chat.db')
    c = sql_conn.cursor()

    while True:
        try:
            data = conn.recv(1024)

            if data:
                op_code, contents = unpack_packet(data)

                """prints the message and address of the
                user who just sent the message on the server
                terminal"""
                print(f"<{addr[0]}> {op_code}|{contents}")

                responses = chat_app.handler(
                    curr_user, int(op_code), contents)

                # Iterate and send out each new response generated by the server
                for recip_conn, response in responses:
                    output = pack_packet(1, response)
                    # write the id, message, and client to the sql database
                    c.execute("INSERT INTO messages VALUES (?, ?, ?)", (id, response, recip_conn))
                    recip_conn.send(output)
                    id += 1
                    time.sleep(0.1)

            # If data has no content, we remove the connection
            else:
                chat_app.handler(curr_user, 3)

        except:
            break
